<!DOCTYPE html>
<html>
  <head>
    <title>Автоматизация задач в GRASS GIS</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      body { font-family: 'Arial'; }
      h1, h2, h3 {
        font-family: 'Arial';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Arial'; }

      .remark-slide-content h1 { font-size: 1.9em; }
      .remark-slide-content h2 { font-size: 1.5em; }
      .remark-slide-content h3 { font-size: 1.3em; }

      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .inverse h3{
        color: #d0d0d0;
        line-height: 0.8em;
      }

      .small {font-size: 0.9em;}
      .tiny {font-size: 0.5em;}

      .footnote {font-size: 0.8em; color: #7070aa;}

      /* Two-column layout */
      .left-column {
        color: #000;
        width: 30%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 60%;
        float: right;
        padding-top: 1em;
      }

    </style>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Автоматизация задач в GRASS GIS 
### Колесов Д., Мурый А. 

---
# Содержание

1. Обзор графического интерфейса
2. Знакомство с командами GRASS
3. Простейшая циклическая обработка
4. Последовательность команд == скрипт
5. Создание модулей GRASS 
6. Параллелизация "для бедных"


---
# Графичекий интерфейс пользователя

.center[<img src="img/GUI.png" width=500  />]

1. Окно терминала (консоль). Активно используется при работе с коммандной строкой, особенно под ОС Linux, MacOS.
2. Окно менеджера слоев:
  * Дерево слоев.
  * Командная консоль ("бедная").
  * Поиск модулей.
  * Интерпретатор Python.
3. Окно карты.

---

# Интерполяция сплайнами 

Метод сплайнов (модуль v.surf.rst, Regularized Spline with Tension) моделирует поведение гибкой растяжимой пластины, которая закрепляется между точками. 

```bash
v.surf.rst -c input=name [zcolumn=name] elevation=name aspect=name where=sql_query \
	tension=float smooth=float 
```
Параметры:
* input=name название входной векторной карты с высотами;
* zcolumn=name название столбца, в котором хранятся высоты;
* elevation=name название выходной растровой карты с высотами;
* aspect=name название выходной растровой карты с экспозицией склонов;
* where=sql_query sql запрос для выбоки точек, учавствующих в расчетах;

Пример запуска:
```bash
g.region vector=elev_points res=2
v.surf.rst elev_points elev=elev_2m zcol=value aspect=asp_2m
r.colors map=asp_2m color=aspect
```
---
# Параметры настройки: tension и smooth
Метод сплайнов моделирует поведение гибкой растяжимой пластины, которая закрепляется между точками. 

* tension (растяжение) параметр моделирует степень растяжения пластины в диапазоне от жесткой пластины до эластичной мембраны. Чем меньше
значение параметра, тем тверже считается пластина, соответственно на выходе получаются малорельефные, "плоские" поверхности. 
Соответственно в местах резкого изменения высот низкие значения параметра излишне сглаживают рельеф. Высокие значения параметра
приводят к созданию эластичной резиновой мембраны, и в результате каждая точка "вытягивает" эту мембрану в свою сторону и вокруг точек появляются 
локальные "пики" или "ямы".
* smooth (гладкость) параметр можно представить как пружины, прицепленные к каждой точке, которые "тянут" пластину к себе. Чем больше значение
параметра, тем "мягче" пружина и тем большее допустимое отклонение пластины от точек. Чем меньше параметр, тем сильнее пружина, и при нулевом значении 
параметра пластина пройдет точно через точку. (GRASS позволяет задать каждой точке свое значение smooth)


---
# Точность построений

Будем оценивать точность построений на базе поцедуры перекрестной проверки:

1. "Спрячем" часть точек от процедуры построения рельефа: удалим точки из исходной карты (поместим их во вспомогательную карту).
2. Выберем параметры tension и smooth.
3. Построим рельеф на базе оставшихся точек.
4. Найдем погрешность для тех точек, которые были удалены из исходных данных.
5. Выберем новые параметры tension и smooth и повторим процедуру.

В итоге, повторяя процедуру для разных параметров мы будем получать разные погрешности нашего рельефа. 
Тот набор параметров, который обеспечивает наименьшую погрешность в "незнакомых" точках мы и будем использовать
как оптимальный.

**Замечание** Процедура перекрестной проверки уже встроена в модуль, но мы воспроизведём ее в учебных целях.

---
# Подготовка данных для расчетов

1. Разобьем точки на обучающее и тестовое множество.
```bash
g.copy vector=elev_points@PERMANENT,elevation
v.kcv map=elevation@user1 npartitions=10
v.extract input=elevation output=test where="part=10"
v.db.addcolumn map=test columns="elev double, error double"
v.edit map=elevation tool=delete where="part=10"
```

2. Строим рельеф и считываем с него данные
```bash
v.surf.rst elev_points elev=elev_2m zcol=value smooth=10 tension=0.1 --o
v.what.rast map=test raster=elev_2m column=elev
```

3. Находим погрешность
```bash
v.db.update map=test column=error query_column="value - elev"
v.univar map=test column=error
```

    </textarea>
	<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });
      MathJax.Hub.Queue(function() {
          $(MathJax.Hub.getAllJax()).map(function(index, elem) {
              return(elem.SourceElement());
          }).parent().addClass('has-jax');
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
